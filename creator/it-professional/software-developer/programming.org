
* Languages
** Python
*** Events
**** Meetups
***** Budapest.py
****** DONE Prepare for pythonr workshop 4
       SCHEDULED: <2019-10-09 Wed>
****** DONE Participate on python workshop 4
       SCHEDULED: <2019-10-09 Wed>
**** Conferences
** Scala
*** Learning
**** Online courses
***** DONE Functional programming principles with Scala
***** DONE Functional program design with Scala
**** Books
***** DONE Scala language
***** TODO Red book
***** TODO Essential Scala
***** TODO Scala with cats
****** Introduction
******* The type class pattern
	There are three important components to the type class pattern: the type class itself, instances for
	particular types, and the interface methods that we expose to users.
******** The type class
	 A type class is an interface or API that represents some functionality we want to implement. In Cats
	 a type class is represented by a trait with at least one type parameter.
	 #+BEGIN_SRC scala
	 // Define a very simple JSON AST
	 sealed trait Json
	 final case class JsObject(get: Map[String, Json]) extends Json
	 final case class JsString(get: String) extends Json
	 final case class JsNumber(get: Double) extends Json
	 case object JsNull extends Json

	 // The "serialize to JSON" behaviour is encoded in this trait
	 trait JsonWriter[A] {
           def write(value: A): Json
	 }
	 #+END_SRC
	 ~JsonWriter~ is our type class in this example, with ~Json~ and its subtypes providing supporting code.
******** Type class instances
	 The instances of a type class provide implementations for the types we care about, including types from
	 the Scala standard library and types from our domain model. In Scala we define instances by creating
	 concrete implementations of the type class and tagging them with the ~implicit~ keyword
	 #+BEGIN_SRC scala
	 final case class Person(name: String, email: String)

         object JsonWriterInstances {
           implicit val stringWriter: JsonWriter[String] =
             new JsonWriter[String] {
               def write(value: String): Json =
                 JsString(value)
             }

           implicit val personWriter: JsonWriter[Person] =
             new JsonWriter[Person] {
               def write(value: Person): Json =
                 JsObject(Map(
                   "name" -> JsString(value.name),
                   "email" -> JsString(value.email)
                 ))
             }

           // etc...
         }
	 #+END_SRC
******** Type class interfaces
	 A type class interface is any functionality we expose to users. Interfaces are generic methods that
	 accept instances of the type class as implicit parameters. There are two common ways of specifying an
	 interface: Interface Objects and Interface Syntax.
********* Interface objects
	  The simplest way of creating an interface is to place methods in a singleton object
          #+BEGIN_SRC scala
 object Json {
   def toJson[A](value: A)(implicit w: JsonWriter[A]): Json =
     w.write(value)
 }
	  #+END_SRC
	  To use this object, we import any type class instances we care about and call the relevant method:
          #+BEGIN_SRC scala
 import JsonWriterInstances._

 Json.toJson(Person("Dave", "dave@example.com"))
 // res4: Json = JsObject(Map(name -> JsString(Dave), email -> JsString(dave@example.com)))
	  #+END_SRC
	  The compiler spots that we’ve called the ~toJson~ method without providing the implicit parameters. It
	  tries to fix this by searching for type class instances of the relevant types and inserting them at
	  the call site:
          #+BEGIN_SRC scala
 Json.toJson(Person("Dave", "dave@example.com"))(personWriter)
	  #+END_SRC
********* Interface Syntax
	  We can alternatively use /extension methods/ to extend existing types with interface methods. Cats refers
	  to this as “syntax” for the type class:
          #+BEGIN_SRC scala
 object JsonSyntax {
   implicit class JsonWriterOps[A](value: A) {
     def toJson(implicit w: JsonWriter[A]): Json =
       w.write(value)
   }
 }
	  #+END_SRC
	  We use interface syntax by importing it alongside the instances for the types we need:
          #+BEGIN_SRC scala
 import JsonWriterInstances._
 import JsonSyntax._

 Person("Dave", "dave@example.com").toJson
 // res6: Json = JsObject(Map(name -> JsString(Dave), email -> JsString(dave@example.com)))
	  #+END_SRC
	  Again, the compiler searches for candidates for the implicit parameters and fills them in for us:
          #+BEGIN_SRC scala
 Person("Dave", "dave@example.com").toJson(personWriter)
	  #+END_SRC
********* The /implicitly/ method
	  The Scala standard library provides a generic type class interface called implicitly. Its definition
	  is very simple:
          #+BEGIN_SRC scala
 def implicitly[A](implicit value: A): A =
   value
	  #+END_SRC
	  We can use implicitly to summon any value from implicit scope. We provide the type we want and
	  implicitly does the rest:
          #+BEGIN_SRC scala
 import JsonWriterInstances._
 // import JsonWriterInstances._

 implicitly[JsonWriter[String]]
 // res8: JsonWriter[String] = JsonWriterInstances$$anon$1@642f308c
	  #+END_SRC
******* Working with implicits
******** Packaging implicits
	 In a curious quirk of the language, any definitions marked ~implicit~ in Scala must be placed inside
	 an object or trait rather than at the top level. In the example above we packaged our type class
	 instances in an object called ~JsonWriterInstances~. We could equally have placed them in a companion
	 object to ~JsonWriter~. Placing instances in a companion object to the type class has special
	 significance in Scala because it plays into something called /implicit scope/.
******** Implicit scope
	 The compiler searches for candidate instances in the implicit scope at the call site, which roughly consists of:
         - local or inherited definitions;
	 - imported definitions;
	 - definitions in the companion object of the type class or the parameter type (in this case ~JsonWriter~ or ~String~).
	 Definitions are only included in implicit scope if they are tagged with the ~implicit~ keyword.
	 Furthermore, if the compiler sees multiple candidate definitions, it fails with an /ambiguous
	 implicit/ values error.

	 [[https://stackoverflow.com/questions/5598085/where-does-scala-look-for-implicits][Where does Scala look for implicits?]]

	 [[http://eed3si9n.com/revisiting-implicits-without-import-tax][Blogpost about implicit priority]]

	 We can package type class instances in roughly four ways:
         - by placing them in an object such as JsonWriterInstances;
	 - by placing them in a trait;
	 - by placing them in the companion object of the type class;
	 - by placing them in the companion object of the parameter type.
	 With option 1 we bring instances into scope by importing them. With option 2 we bring them into scope
	 with inheritance. With options 3 and 4, instances are always in implicit scope, regardless of where
	 we try to use them.
******** Recursive implicit resolution
	 The power of type classes and implicits lies in the compiler’s ability to combine implicit definitions
	 when searching for candidate instances. We can define instances in two ways:
         - by defining concrete instances as ~implicit vals~ of the required type;
	 - by defining ~implicit~ methods to construct instances from other type class instances.
	 Why would we construct instances from other instances? As a motivational example, consider defining a
	 ~JsonWriter~ for ~Options~. We would need a ~JsonWriter[Option[A]]~ for every ~A~ we care about in our
	 application. We could try to brute force the problem by creating a library of ~implicit vals~, however,
	 this approach clearly doesn’t scale. We end up requiring two ~implicit vals~ for every type ~A~ in our
	 application: one for ~A~ and one for ~Option[A]~. Fortunately, we can abstract the code for handling
	 ~Option[A]~ into a common constructor based on the instance for ~A~:
          #+BEGIN_SRC scala
 implicit def optionWriter[A]
     (implicit writer: JsonWriter[A]): JsonWriter[Option[A]] =
   new JsonWriter[Option[A]] {
     def write(option: Option[A]): Json =
       option match {
         case Some(aValue) => writer.write(aValue)
         case None         => JsNull
       }
   }
	  #+END_SRC
	  This method constructs a ~JsonWriter~ for ~Option[A]~ by relying on an implicit parameter to fill in
	  the ~A~-specific functionality. When the compiler sees an expression like this:
          #+BEGIN_SRC scala
 Json.toJson(Option("A string"))
	  #+END_SRC
	  it searches for an implicit ~JsonWriter[Option[String]]~. It finds the implicit method for ~JsonWriter[Option[A]]~:
          #+BEGIN_SRC scala
 Json.toJson(Option("A string"))(optionWriter[String])
	  #+END_SRC
	  and recursively searches for a ~JsonWriter[String]~ to use as the parameter to optionWriter:
          #+BEGIN_SRC scala
 Json.toJson(Option("A string"))(optionWriter(stringWriter))
	  #+END_SRC
	  In this way, implicit resolution becomes a search through the space of possible combinations of implicit
	  definitions, to find a combination that summons a type class instance of the correct overall type.
***** TODO Shapeless guide
*** Events
**** Meetups
***** Budapest.scala
**** Conferences
* Paradigms
** Functional programming
   - *Functional programming*: Programming using only pure functions.
   - *Pure function*: A function without side effects. An expression ~f(x)~ is referencially transparent if the
     function ~f~ is pure and the expression ~x~ is RT.
   - *Referencial transparency*: An expression is RT, if we can substitute it with it's result without changing
     the meaning (behaviour) of the program.
* Exercises
** Seasonal challenges
*** Advent of code
**** [[https://adventofcode.com/2019/day/1][2019]]
* Software architecture
** Architectural patterns
*** Command Query Responsibility Segregation (CQRS)
    - [[https://culttt.com/2015/01/14/command-query-responsibility-segregation-cqrs/][Blogpost]]
      With further links
